
/***********************************************************************
 *  This code is part of CMPL
 *
 *  Copyright (C) 2007, 2008, 2009, 2010, 2011
 *  Mike Steglich - Technical University of Applied Sciences
 *  Wildau, Germany and Thomas Schleiff - Halle(Saale),
 *  Germany
 *
 *  Coliop3 and CMPL are projects of the Technical University of
 *  Applied Sciences Wildau and the Institute for Operations Research
 *  and Business Management at the Martin Luther University
 *  Halle-Wittenberg.
 *  Please visit the project homepage <www.coliop.org>
 *
 *  CMPL is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  CMPL is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, see <http://www.gnu.org/licenses/>.
 *
 ***********************************************************************/


#ifndef INTERPRETER_HH
#define INTERPRETER_HH


#include "../../Control/ModuleBase.hh"
#include "../../Control/ThreadHandler.hh"
#include "../../CommonData/SyntaxElements.hh"
#include "../../CommonData/IntCode.hh"
#include "../../CommonData/OptModel.hh"
#include "../../CommonData/ExternDataInfo.hh"


using namespace std;



namespace cmpl
{
	class ExecContext;
	class SymbolValue;


    /**
	 * the <code>Interpreter</code> class executes the intermediary code
	 */
	class Interpreter : public ModuleBase
	{
		friend class ExecContext;


		/************** command line options **********/
	private:
        short _intOutOfRangeMode;                       ///< mode for handling literal integer values out of integer range (one of INT_OPER_OORANGE_*)
        ThreadHandler _threadHandler;                   ///< info for limiting the number of concurrently running threads

        bool _orderedIter;                              ///< use ordered execution in all explicit and implicit iterations
        bool _echoDuration;                             ///< include duration since start in all outputs of echo function

        map<string, string> _fileAlias;					///< file name aliases for data files
        map<string, unsigned> _fileAliasPrio;			///< priority of file name aliases (same keys as in _fileAlias)

        unsigned _nmPrefSep;                            ///< separator between and after line name prefixes (0: no such separator)
        int _nmPrefAfter;                               ///< separator only after line name prefixes (-1: use _nmPrefSep)

        //TODO


	private:
        /************** data generated by the compiler module **********/
        IntCode::IcElem *_code;							///< array with intermediary code
		unsigned _codeCnt;								///< count of elements in _code

		map<unsigned, SymbolInfo *> *_symbolInfo;		///< symbol infos

		SyntaxElement *_syntaxStructure;				///< root element of syntax structure of cmpl input
		map<unsigned, const SyntaxElement *> *_syntaxElems;	///< syntax elements by id, only filled for error output

		SymbolValue *_globSymbols;						///< array for values of global symbols, indexed by the symbol definition number

        /************** special symbol definition numbers **********/
        unsigned _symIdSubAsVar;                        ///< symbol definition number for subsymbol "as_var"
        unsigned _symIdSubAsCon;                        ///< symbol definition number for subsymbol "as_con"
        unsigned _symIdSubAsObj;                        ///< symbol definition number for subsymbol "as_obj"
        unsigned _symIdSubAsString;                     ///< symbol definition number for subsymbol "as_string"

        /************** data for interpreter module **********/
        map<tp_e, CmplValAuto> _dataTypes;              ///< data type objects by TP_DATA_BASETYPE
        CmplValAuto _defTypeVar;						///< default data type for optimization variables

        ExecContext *_baseExecCtx;                      ///< base execution context, set only while executing execCode()
        OptModel *_resModel;							///< result optimization model


    public:
		/**
		 * destructor
		 */
		~Interpreter();

        /**
         * get mode for handling literal integer values out of integer range (one of INT_OPER_OORANGE_*)
         */
        inline short intOutOfRangeMode()                            { return _intOutOfRangeMode; }

        /**
         * info for limiting the number of concurrently running threads
         */
        inline ThreadHandler& threadHandler()                       { return _threadHandler; }

        /**
         * get whether to use ordered execution in all explicit and implicit iterations
         */
        inline bool orderedIter()                                   { return _orderedIter; }

        /**
         * get whether to include duration since start in all outputs of echo function
         */
        inline bool echoDuration()                                  { return _echoDuration; }

        /**
         * get separator between and after line name prefixes
         */
        inline unsigned nmPrefSep(bool aft)                         { return (aft && _nmPrefAfter >= 0 ? (unsigned) _nmPrefAfter : _nmPrefSep); }

        /**
         * get file name aliases for data files
         */
        inline map<string, string>& fileAlias()                     { return _fileAlias; }

        /**
         * get base execution context
         */
        inline ExecContext *baseExecCtx()                           { return _baseExecCtx; }

        /**
         * get result optimization model
         */
        inline OptModel *getResModel()								{ return _resModel; }

        /**
         * get map of data type objects by TP_DATA_BASETYPE
         */
        inline map<tp_e, CmplValAuto>& dataTypes()                  { return _dataTypes; }

        /**
         * default data type for optimization variables
         */
        inline CmplVal& defTypeVar()								{ return _defTypeVar; }

        /**
         * data type for real optimization variables
         */
        inline CmplVal& realTypeVar()								{ return _dataTypes[TP_REAL]; }

        /**
         * data type for integer optimization variables
         */
        inline CmplVal& intTypeVar()								{ return _dataTypes[TP_INT]; }

        /**
         * data type for binary optimization variables
         */
        inline CmplVal& binTypeVar()								{ return _dataTypes[TP_BIN]; }

        /**
         * get symbol info for a symbol
         * @param defId		definition number of the symbol
         * @return 			symbol info or NULL if not found
         */
        inline SymbolInfo *symbolInfo(unsigned defId)				{ return (_symbolInfo->count(defId) ? _symbolInfo->at(defId) : NULL); }

        /**
         * get symbol definition number for subsymbol "as_var"
         */
        inline unsigned symIdSubAsVar()                             { return _symIdSubAsVar; }

        /**
         * get symbol definition number for subsymbol "as_con"
         */
        inline unsigned symIdSubAsCon()                             { return _symIdSubAsCon; }

        /**
         * get symbol definition number for subsymbol "as_obj"
         */
        inline unsigned symIdSubAsObj()                             { return _symIdSubAsObj; }

        /**
         * get symbol definition number for subsymbol "as_string"
         */
        inline unsigned symIdSubAsString()                          { return _symIdSubAsString; }


		/************** overwritten methods of <code>ModuleBase</code> **********/

	public:
		/**
		 * initialize modul, to call immediately after the constructor.
		 * @param ctrl			main object
		 * @param data			data object
		 * @param name			module name (or alias)
		 */
		virtual void init(MainControl *ctrl, MainData *data, const char *name);

		/**
		 * run module function
		 */
		virtual void run();

        /**
         * get whether value access need locks because of concurrent threads
         */
        virtual bool needLocks() const              { return _threadHandler.needLocks(); }

	protected:
		/**
		 * register command line options options for delivery to this module
		 * @param modOptReg		vector to register in
		 */
		virtual void regModOptions(vector<CmdLineOptList::RegOption> &modOptReg);

		/**
		 * parse single option from command line options, this function is called for every delivered option
		 * @param ref			reference number of option registration, should be used for discriminate the options
		 * @param prio			priority value of option
		 * @param opt			option
		 * @return				true if option is used by the module
		 */
		virtual bool parseOption(int ref, int prio, CmdLineOptList::SingleOption *opt);

        /**
         * execute step for every registered extension for a single command line option
         * @param extStep       extension execution step
         * @param extRef        map from extension identifier to command line option reference key
         * @param prio          priority value of option
         * @param opt           option
         * @return              true if option is used by an extension
         */
        virtual bool execExtOption(int extStep, map<int, int>& extRef, int prio, CmdLineOptList::SingleOption *opt);

		/**
		 * writes usage info for the module to stream
		 * @param s				stream to write to
		 */
		virtual void usage(ostream& s);



        /****** import of extern data values ****/

    private:
        mutex _externMtx;                       ///< mutex for reading external data
        ExternDataInfo *_externInfo;            ///< info for external data, provided by the precompiler

    public:
        /**
         * import external data values
         * @param ctx       execution context
         * @param se        id of syntax element
         * @param res		return values
         * @param symNmsName symbol name including namespace
         */
        void importExtern(ExecContext *ctx, unsigned se, CmplVal& res, string& symNmsName);

        /**
         * get the syntax element for a given id
         * @param id		id of syntax element
         * @return			syntax element
         */
        const SyntaxElement *syntaxElement(unsigned id);


		/****** internal methods ****/

	private:
		/**
		 * initialize symbols
		 */
		void initSymbols();

        /**
         * initialize map _dataTypes
         */
        void initDataTypes();

		/**
		 * initialize predefined values
		 * @param sv		pointer to symbol value
		 * @param predef	id of predefined value
		 * @param predefMap	map with already initialized predefines
		 */
		void initPredef(SymbolValue *sv, int predef, map<int, SymbolValue *>& predefMap);

        /**
         * initialize predefined values
         * @param sy		pointer to symbol info
         * @param predefMap	map with already initialized predefines
         */
        void initPredefSub(SymbolInfo *sy, map<int, SymbolValue *>& predefMap);

        /**
         * set special symbol definition numbers for subsymbols
         * @param sy        pointer to symbol info
         */
        void initSpecialSub(SymbolInfo *sy);

		/**
		 * execute intermediary code
		 */
		void execCode();
	};


    /**
     * class for data exchange with extension class for import of extern data
     */
    struct ImportExternDataInfo
    {
        CmplVal& result;                            ///< result value
        ExternDataInfo::EIRecord *externInfo;       ///< info for extern data
        ExecContext *execContext;                   ///< calling execution context
        unsigned syntaxElem;                        ///< id of syntax element

        /**
         * constructor
         */
        ImportExternDataInfo(CmplVal& r, ExternDataInfo::EIRecord *ei, ExecContext *ctx, unsigned se): result(r), externInfo(ei), execContext(ctx), syntaxElem(se)  { }
    };
}

#endif // INTERPRETER_HH

