
/***********************************************************************
 *  This code is part of CMPL
 *
 *  Copyright (C) 2007, 2008, 2009, 2010, 2011
 *  Mike Steglich - Technical University of Applied Sciences
 *  Wildau, Germany and Thomas Schleiff - Halle(Saale),
 *  Germany
 *
 *  Coliop3 and CMPL are projects of the Technical University of
 *  Applied Sciences Wildau and the Institute for Operations Research
 *  and Business Management at the Martin Luther University
 *  Halle-Wittenberg.
 *  Please visit the project homepage <www.coliop.org>
 *
 *  CMPL is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  CMPL is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, see <http://www.gnu.org/licenses/>.
 *
 ***********************************************************************/


#ifndef OUTMODELMPS_HH
#define OUTMODELMPS_HH

#include <string>
#include <iostream>

#include "../../Control/ModuleBase.hh"
#include "../../CommonData/OptModel.hh"
#include "../../CommonData/SyntaxElements.hh"
#include "OutModelExtData.hh"


using namespace std;



namespace cmpl
{
	class OptModel;


    /**
	 * <code>OutModelMps</code> is used to write the model generated by the Interpreter module to a file in the MPS format.
	 */
	class OutModelMps : public ModuleBase
	{
    private:
        /**
         * type for an extension of the MPS format
         */
        enum FormatExtension {
            FormatExtensionNone,                ///< don't use extension

            FormatExtensionDefault,             ///< change value to default (only used while parsing command line options)
            FormatExtensionError,               ///< unknown type name (only used while parsing command line options)

            FormatExtensionCplex,               ///< format used by solver CPLEX
            FormatExtensionGurobi,              ///< format used by solver GUROBI
            FormatExtensionScip,                ///< format used by solver SCIP
            FormatExtensionHighs,               ///< format used by solver HiGHS
        };

		/************** command line options **********/

	private:
		FileOutput *_standardMps;				///< write model as standard MPS to this file / NULL: no standard MPS output
		FileOutput *_freeMps;					///< write model as free MPS to this file / NULL: no free MPS output

        FormatExtension _formatDefault;         ///< default for subsequent format selection options
        FormatExtension _formatHeader;          ///< format of header lines in MPS
        FormatExtension _formatSOS;             ///< format of MPS extension for SOS
        FormatExtension _formatQP;              ///< format of MPS extension for quadratic problems
        //TODO: more format extensions

        string _realFormat;						///< printf format for output of real values

        SyntaxElement *_syntaxStructure;				///< root element of syntax structure of cmpl input
        map<unsigned, const SyntaxElement *> *_syntaxElems;	///< syntax elements by id, only filled for error output

        bool _exportOnly;
        string _objName;
        bool _integerRelaxation;

        int _addConForUnusedVar;                ///< add pseudo constraint for otherwise unused variable: 0: no / 1: yes if unused because of deletion of a constraint / 2: yes for all)

        map<int, list<OutModelExtDataBase::Info> > _mki;


	public:
		/**
		 * destructor
		 */
		~OutModelMps();


		/************** overwritten methods of <code>ModuleBase</code> **********/

	public:
		/**
		 * initialize modul, to call immediately after the constructor.
		 * @param ctrl			main object
		 * @param data			data object
		 * @param name			module name (or alias)
		 */
		virtual void init(MainControl *ctrl, MainData *data, const char *name);

		/**
		 * run module function
		 */
		virtual void run();

	protected:
		/**
		 * register command line options options for delivery to this module
		 * @param modOptReg		vector to register in
		 */
		virtual void regModOptions(vector<CmdLineOptList::RegOption> &modOptReg);

		/**
		 * parse single option from command line options, this function is called for every delivered option
		 * @param ref			reference number of option registration, should be used for discriminate the options
		 * @param prio			priority value of option
		 * @param opt			option
		 * @return				true if option is used by the module
		 */
		virtual bool parseOption(int ref, int prio, CmdLineOptList::SingleOption *opt);

		/**
		 * writes usage info for the module to stream
		 * @param s				stream to write to
		 */
		virtual void usage(ostream& s);


		/************** module functionality **********/

	private:
        /**
         * parse argument of command line option for name of MPS format extension
         * @param opt           command line option
         * @return              format extension type
         */
        FormatExtension parseFormatExtName(CmdLineOptList::SingleOption *opt);

        /**
         * initialize use of MPS format extensions
         */
        void initFormatExtFromDefault();

        /**
         * write generated model to file
		 * @param om			generated model
		 * @param file			output to this file
		 * @param fm			use free MPS format
		 */
		void writeModel(OptModel *om, FileOutput *file, bool fm);

        /**
         * write generated model to stream
         * @param om			generated model
         * @param ostr			output to this stream
         * @param fm			use free MPS format
         */
        void writeModel(OptModel *om, ostream& ostr, bool fm);

        /**
         * write mps sections for quadratic problems
         * @param ostr          output to this stream
         * @param fm            use free MPS format
         * @param qm            linear model with quadratic extension
         * @param rowNames      array of all row names
         * @param colNames      array of all column names
         * @param obj           true: write mps for quadratic objective / false: write mps for quadratic constraints
         * @param objRowNr      row number of objective
         */
        void writeQuadratics(ostream& ostr, bool fm, QLinearModel *qm, string *rowNames, string *colNames, bool obj, unsigned long objRowNr);

        /**
         * fill mapping with quadratic coefficients for one row
         * @param pm            mapping to fill coefficients in
         * @param cvp           list of quadratic terms
         */
        void fillQuadraticMap(map<unsigned long, map<unsigned long, LinearModel::Coefficient>>& pm, list<QLinearModel::CoefficientVarProd>& cvp);

        /**
         * write mps section for SOS
         * @param ostr          output to this stream
         * @param type          type of SOS (1 or 2)
         * @param fm            use free MPS format
         * @param i             internal SOS index
         * @param colNames      array of all column names
         * @param sosvars       variables in SOS
         * @param sosName       name of SOS
         */
        void writeSos(ostream& ostr, int type, bool fm, unsigned i, string *colNames, vector<unsigned long>& sosvars, string& sosName) ;

        /**
         * write column coefficients for one column
         * @param ostr			output to this stream
         * @param fm			use free MPS format
         * @param cn			column name
         * @param rns			row names
         * @param coeffs		coefficients for the column
         */
        void writeColCoeffs(ostream& ostr, bool fm, string& cn, string *rns, const vector<LinearModel::Coefficient> &coeffs);

        /**
         * write bounds for one column
         * @param ostr			output to this stream
         * @param fm			use free MPS format
         * @param cn			column name
         * @param bt			MPS type of bound
         * @param bv			value of bound or NULL if the bound type doesn't have one
         */
        void writeColBound(ostream& ostr, bool fm, string& cn, const char *bt, CmplVal *bv = NULL);

        /**
         * get the syntax element for a given id
         * @param id		id of syntax element
         * @return			syntax element
         */
        const SyntaxElement *syntaxElement(unsigned id);
    };
}

#endif // OUTMODELMPS_HH

