//
// Produktionsprogrammplanung unter Einbeziehung von Lernkurveneffekten
//
// Beispiel von Mike Steglich 20.10.2007
//

const:
	// Beispielhaft wird hier von 2 Produkten, 3 Produktionsfaktoren und 2 Arbeitsplätzen ausgegangen
	Produkte = 2;
	Faktoren = 3;
	Plaetze = 2;

	// Absatzpreis
 	Absatzpreis[1..Produkte] = (20, 30);
 
 	// Stückkosten ohne Fertigungseinzelkosten
 	Stueckkosten[1..Produkte] = (10, 18);
 
 	// Kostensatz pro Zeiteinheit für die Arbeit pro Arbeitsplatz
 	Kostensatz[1..Plaetze] = (1.3, 1.5);
 
 	// Produktionskoeffizienten pro Produktionsfaktor und Produkt
 	A[1..Faktoren, 1..Produkte] = ((1.0, 1.0), (1.2, 1.8), (1.4, 1.3));
 
 	// Obergrenze pro Produktionsfaktor
 	B[1..Faktoren] = (40, 60, 70);
 
 	// Maximale Personalkapazität pro Arbeitsplatz
 	T[1..Plaetze] = (80, 100);
 
 	// Maximale Menge pro Produkt
 	xMax[1..Produkte] = (100, 100);
 
 	// Produktionsmenge pro Linearisierungsintervall
 	// Für das Produkt 1 gibt es 2 Linearisierungsintervalle, für das Produkt 2 gibt es 3
 	xniMax[1..Produkte, ] = ((3, 100), (2, 4, 100));
 	
 	// Produktionskoeffizienten pro Arbeitsplatz, Produkt und Linearisierungsintervall
 	// (Die Werte müssen direkt hier eingetragen werden, weil die log-Funktion zur Berechnung
 	// aus Ausgangswerten hier nicht implementiert ist (die übrige Berechnung wäre hier möglich))
 	tkni[1..Plaetze, 1..Produkte, ] =
 		(((1.6, 1.2), (2.1, 1.8, 1.7)),
 		 ((2.5, 2.2), (3.2, 2.8, 2.6)));

echo "QQQ";

include "a/test.gen"

echo "XXX";

include "09_Include.gen"

 var:
 	// Produktionsprogramm
 	x[1..Produkte] : real[0..];
 
 	// Gesamte zeitliche Beanspruchung der Arbeit pro Arbeitsplatz und Produkt
 	rkn[1..Plaetze, 1..Produkte] : real[0..];
 
 	// (Hier Schleife über Produkte, da die Produkte unterschiedlich viele Linearisierungsintervalle haben)
 	{n = 1(1)Produkte:
 		// Produktion pro Linearisierungsstück
 		xni[n, 1..dim(xniMax[n,])] : real[0..];
 
 		// Hilfsvariablen für Reihenfolge der Linearisierungsintervalle
 		// (Jeweils die letzte y-Variable taucht in den Restriktionen gar nicht auf,
 		//  sie wird deshalb trotz der Definition hier gar nicht in die generierte Matrix aufgenommen)
 		y[n, 1..dim(xniMax[n,])] : binary;
 	}
 
 
 // Zielfunktion
 objective:
 	sum{n=1(1)Produkte: (Absatzpreis[n] - Stueckkosten[n]) * x[n]}
 		+ sum{n=1(1)Produkte, k=1(1)Plaetze: -Kostensatz[k] * rkn[k,n]};
 	
 // Restriktionen
 constraint:
 	// Basisproblem über Produktionsfaktoren
 	A[,] * x[] <= B[];
 
 	// Berechnung der rkn
 	RS {k=1(1)Plaetze, n=1(1)Produkte:
 		//RS$k$x$n$:
			rkn[k,n] = sum{i=1(1)dim(xniMax[n,]): tkni[k,n,i] * xni[n,i]};
 	}
 
 	// Beschränkung der verfügbaren Zeitkapazität
 	{k=1(1)Plaetze:
 		sum{n=1(1)Produkte: rkn[k,n]} <= T[k];
 	}
 
 	// Bedingung für Reihenfolge der Linearisierungsintervalle
 	{n=1(1)Produkte:
 		x[n] = sum{i=1(1)dim(xniMax[n,]): xni[n,i]};
 
 		{i=1(1)dim(xniMax[n,]):
 			{i < dim(xniMax[n,]): xni[n,i] >= y[n,i] * xniMax[n,i]; }
 			{i > 1:               xni[n,i] <= y[n,i-1] * xniMax[n,i]; }
 		}
 	}
 
 	// Schranken
 	0 <= x[] <= xMax[];
 	{n=1(1)Produkte: 0 <= xni[n,] <= xniMax[n,]; }
	
